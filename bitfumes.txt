use laravel scout and algolia:
1 - composer require laravel/scout
2 - php artisan vendor:publish --provider="Laravel\Scout\ScoutServiceProvider" :
After installing Scout, you should publish the Scout configuration using the vendor:publish Artisan command.
This command will publish the scout.php configuration file to your config directory
3 - migrate users or any model you want to search, in this case users
4- add this commands in model class:
	use Laravel\Scout\Searchable;
	use Searchable;

5 - create alogolia account
6 - composer require algolia/algoliasearch-client-php
7 - add to model this function:
  public function searchableAs()
    {
        return 'name';
    }

8 - add id and secret key to laravel scout.php config from site:
application ID -id,
Admin API key - secret

9- then add new user and it should be visible on the site
10 - php artisan scout:import "App\Post" this command allows us to import data to algolia
11 - php artisan scout:flush "App\Post" and this command allows to remove data from algolia

12 - next in route and controller we pass search key, and after that we should return all related models:
Route::get('/search/{searchKey}', 'HomeController@search');

public function search($searchKey){
        $users = User::search($searchKey)->get();
        return view('search', compact('users'));
}

@foreach($users as $user)
    name: {{$user->name}}
    <br>
    email: {{$user->email}}
    <br>
    <br>
    <br>
@endforeach






laravel norifications:
creating notifications - php artisan make:notification InvoicePaid
after that we can access class of notification, where we can set the type:
 public function via($notifiable)
{
    return ['mail'];
}

instead of mail there could be database, broadcast and etc.

in order to speed up the system of sending email, we need to implement ShouldQueue in Notifications:
class TaskCompleted extends Notification implements ShouldQueue

but before we need to configure Queue in .env:
QUEUE_DRIVER=database
but before we need to create queue table:
php artisan queue:table
php artisan migrate
php artisan queue:work - in order queue to work this should be working constantly

we can also send notification in delay:
$when = now()->addMinutes(10);
$user->notify((new InvoicePaid($invoice))->delay($when));


formating email:
Notification::route('mail', 'taylor@example.com')
            ->route('nexmo', '5555555555')
            ->notify(new InvoicePaid($invoice));

Formatting Mail Messages
If a notification supports being sent as an email, you should define a toMail method on the notification class. This method will receive a $notifiable entity and should return a  Illuminate\Notifications\Messages\MailMessage instance. Mail messages may contain lines of text as well as a "call to action". Let's take a look at an example toMail method:

/**
 * Get the mail representation of the notification.
 *
 * @param  mixed  $notifiable
 * @return \Illuminate\Notifications\Messages\MailMessage
 */
public function toMail($notifiable)
{
    $url = url('/invoice/'.$this->invoice->id);

    return (new MailMessage)
                ->greeting('Hello!')
                ->line('One of your invoices has been paid!')
                ->action('View Invoice', $url)
                ->line('Thank you for using our application!');
}
Note we are using $this->invoice->id in our toMail method. You may pass any data your notification needs to generate its message into the notification's constructor.

In this example, we register a greeting, a line of text, a call to action, and then another line of text. These methods provided by the MailMessage object make it simple and fast to format small transactional emails. The mail channel will then translate the message components into a nice, responsive HTML email template with a plain-text counterpart. Here is an example of an email generated by the mail channel:


When sending mail notifications, be sure to set the name value in your  config/app.php configuration file. This value will be used in the header and footer of your mail notification messages.

Other Notification Formatting Options
Instead of defining the "lines" of text in the notification class, you may use the view method to specify a custom template that should be used to render the notification email:

/**
 * Get the mail representation of the notification.
 *
 * @param  mixed  $notifiable
 * @return \Illuminate\Notifications\Messages\MailMessage
 */
public function toMail($notifiable)
{
    return (new MailMessage)->view(
        'emails.name', ['invoice' => $this->invoice]
    );
}
In addition, you may return a mailable object from the toMail method:

use App\Mail\InvoicePaid as Mailable;

/**
 * Get the mail representation of the notification.
 *
 * @param  mixed  $notifiable
 * @return Mailable
 */
public function toMail($notifiable)
{
    return (new Mailable($this->invoice))->to($this->user->email);
}

Error Messages
Some notifications inform users of errors, such as a failed invoice payment. You may indicate that a mail message is regarding an error by calling the error method when building your message. When using the error method on a mail message, the call to action button will be red instead of blue:

/**
 * Get the mail representation of the notification.
 *
 * @param  mixed  $notifiable
 * @return \Illuminate\Notifications\Message
 */
public function toMail($notifiable)
{
    return (new MailMessage)
                ->error()
                ->subject('Notification Subject')
                ->line('...');
}

Customizing The Recipient
When sending notifications via the mail channel, the notification system will automatically look for an email property on your notifiable entity. You may customize which email address is used to deliver the notification by defining a routeNotificationForMail method on the entity:

<?php

namespace App;

use Illuminate\Notifications\Notifiable;
use Illuminate\Foundation\Auth\User as Authenticatable;

class User extends Authenticatable
{
    use Notifiable;

    /**
     * Route notifications for the mail channel.
     *
     * @param  \Illuminate\Notifications\Notification  $notification
     * @return string
     */
    public function routeNotificationForMail($notification)
    {
        return $this->email_address;
    }
}

Customizing The Subject
By default, the email's subject is the class name of the notification formatted to "title case". So, if your notification class is named InvoicePaid, the email's subject will be Invoice Paid. If you would like to specify an explicit subject for the message, you may call the subject method when building your message:

/**
 * Get the mail representation of the notification.
 *
 * @param  mixed  $notifiable
 * @return \Illuminate\Notifications\Messages\MailMessage
 */
public function toMail($notifiable)
{
    return (new MailMessage)
                ->subject('Notification Subject')
                ->line('...');
}

Customizing The Templates
You can modify the HTML and plain-text template used by mail notifications by publishing the notification package's resources. After running this command, the mail notification templates will be located in the resources/views/vendor/notifications directory:

php artisan vendor:publish --tag=laravel-notifications






creating database notifications:
php artisan notifications:table - create table for storing notifications

then in notification we have to change via method to database:
public function via($notifiable)
    {
        return ['database'];
    }

and we are going to work with toArray method:
 public function toArray($notifiable)
    {
        return [
            //here we can save data
        ];
    }


in order to view our notifcations we can simple access properties of notifiable trait:
public function notifications()
{
    return $this->morphMany(DatabaseNotification::class, 'notifiable')->orderBy('created_at', 'desc');
}

public function readNotifications()
{
    return $this->notifications()->whereNotNull('read_at');
}

public function unreadNotifications()
{
    return $this->notifications()->whereNull('read_at');
}


by the method markAsRead() we can make read notifications:
Route::get('/markallasread', function (){
    auth()->user()->unreadNotifications->markAsRead();
    return back();
})->name('markallasread');
